# Wishbone Bus

## Specification

https://cdn.opencores.org/downloads/wbspec_b4.pdf



## Sample-NOP-Slave

https://github.com/semahawk/wishbone/tree/master/wb_slave_nop



# Point-To-Point

Point-to-point Interconnection (See Page 20)
1. An interconnection system that supports a single WISHBONE MASTER and a
single WISHBONE SLAVE interface. It is the simplest way to connect two cores.
See Illustration 1-7: Point to point interconnection.
2. A connection with only two endpoints.



# 2.2.1 SYSCON Module Signals

Syscon output clk and reset to all masters and slaves. 
This means syscon can clock and reset all bus participants. The bus participants will not run a clock or reset on their own!
They are under control of syscon

## CLK_O
The system clock output [CLK_O] is generated by the SYSCON module. It coordinates all
activities for the internal logic within the WISHBONE interconnect. The INTERCON
module connects the [CLK_O] output to the [CLK_I] input on MASTER and SLAVE
interfaces.

## RST_O
The reset output [RST_O] is generated by the SYSCON module. It forces all WISHBONE
interfaces to restart. All internal self-starting state machines are forced into an initial
state. The INTERCON connects the [RST_O] output to the [RST_I] input on MASTER
and SLAVE interfaces.



# 2.2.2 Signals Common to MASTER and SLAVE Interfaces

## CLK_I
The clock input [CLK_I] coordinates all activities for the internal logic within the
WISHBONE interconnect. All WISHBONE output signals are registered at the rising edge
of [CLK_I]. All WISHBONE input signals are stable before the rising edge of [CLK_I].

## RST_I
The reset input [RST_I] forces the WISHBONE interface to restart. Furthermore, all
internal self-starting state machines will be forced into an initial state. This signal only
resets the WISHBONE interface. It is not required to reset other parts of an IP core
(although it may be used that way).

## DAT_I()
The data input array [DAT_I()] is used to pass binary data. The array boundaries are
determined by the port size, with a maximum port size of 64-bits (e.g. [DAT_I(63..0)]).
Also see the [DAT_O()] and [SEL_O()] signal descriptions.

## DAT_O()
The data output array [DAT_O()] is used to pass binary data. The array boundaries are
determined by the port size, with a maximum port size of 64-bits (e.g. [DAT_I(63..0)]).
Also see the [DAT_I()] and [SEL_O()] signal descriptions.





2.2.3 MASTER Signals

CYC_O
The cycle output [CYC_O], when asserted, indicates that a valid bus cycle is in progress.
The signal is asserted for the duration of all bus cycles. For example, during a BLOCK
transfer cycle there can be multiple data transfers. The [CYC_O] signal is asserted during
the first data transfer, and remains asserted until the last data transfer. The [CYC_O]
signal is useful for interfaces with multi-port interfaces (such as dual port memories). In
these cases, the [CYC_O] signal requests use of a common bus from an arbiter.

STB_O
The strobe output [STB_O] indicates a valid data transfer cycle. It is used to qualify
various other signals on the interface such as [SEL_O()]. The SLAVE asserts either the
[ACK_I], [ERR_I] or [RTY_I] signals in response to every assertion of the [STB_O] signal.

ACK_I
The acknowledge input [ACK_I], when asserted, indicates the normal termination of a bus
cycle. Also see the [ERR_I] and [RTY_I] signal descriptions.

WE_O
The write enable output [WE_O] indicates whether the current local bus cycle is a READ
or WRITE cycle. The signal is negated during READ cycles, and is asserted during WRITE
cycles.

ADR_O()
The address output array [ADR_O()] is used to pass a binary address. The higher array
boundary is specific to the address width of the core, and the lower array boundary is
determined by the data port size and granularity. For example the array size on a 32-bit
data port with BYTE granularity is [ADR_O(n..2)]. In some cases (such as FIFO
interfaces) the array may not be present on the interface.

DAT_I() - see common signals
DAT_O() - see common signals





2.2.4 SLAVE Signals

The problem with the slave below is that it has no 
```
module wb_slave_nop (

	// input
    input wire rst_i,
    input wire clk_i,
	
	// input - slave specific 
    input wire stb_i,    
    input wire cyc_i,
	
	// output
	output wire ack_o
	
);

    // I believe it doesn't get any simpler than this
    assign ack_o = stb_i;

endmodule
```

CYC_I
The cycle input [CYC_I], when asserted, indicates that a valid bus cycle is in progress. The
signal is asserted for the duration of all bus cycles. For example, during a BLOCK transfer
cycle there can be multiple data transfers. The [CYC_I] signal is asserted during the first
data transfer, and remains asserted until the last data transfer.

STB_I
The strobe input [STB_I], when asserted, indicates that the SLAVE is selected. A SLAVE
shall respond to other WISHBONE signals only when this [STB_I] is asserted (except for
the [RST_I] signal which should always be responded to). The SLAVE asserts either the
[ACK_O], [ERR_O] or [RTY_O] signals in response to every assertion of the [STB_I]
signal.

ACK_O
The acknowledge output [ACK_O], when asserted, indicates the termination of a normal
bus cycle. Also see the [ERR_O] and [RTY_O] signal descriptions.

WE_I
The write enable input [WE_I] indicates whether the current local bus cycle is a READ or
WRITE cycle. The signal is negated during READ cycles, and is asserted during WRITE
cycles.

ADR_I()
The address input array [ADR_I()] is used to pass a binary address.

DAT_I() - see common signals
DAT_O() - see common signals






# Transfer Cycle in Standard Mode (3.1.3.1 Standard wishbone protocol)

1. Master asserts [CYC_O] on the rising edge of the clock
1. Slave reads [CYC_I] on the rising edge of the clock
1. MASTER asserts [STB_O] on the rising edge of the clock, when it is ready to transfer data.
-- here data is exchanged --
[STB_O] remains asserted until the SLAVE asserts one of the cycle terminating signals [ACK_I], [ERR_I] or [RTY_I].
1. The masters samples the cycle terminating signals [ACK_I], [ERR_I] or [RTY_I] (if on each rising edge => synchronous slave)
If any is asserted, the master deasserts [CYC_O] and [STB_O]. The cycle is over.

If the slave is synchronous, it will assert the cycle terminating signals [ACK_I], [ERR_I] or [RTY_I] on each rising edge.
An asynchronous slave can assert and deassert the cycle terminating signals any time.

The cycle handshake itself signals the start and end of a cycle.

A very simple slave can just terminate a cycle immediately by asserting [ACK_O] when it sees a [CYC_I].
In this case, no strobes take place.

Within a cycle, strobes





strobe/phase per cycle






# 3.2 SINGLE READ / WRITE Cycles
3.2.1 Classic standard SINGLE READ Cycle (Page 40)

The SINGLE READ / WRITE cycles perform one data transfer at a time. These are the
basic cycles used to perform data transfers on the WISHBONE interconnect.

## CLOCK EDGE 0
HINT: Master asserts and deasserts STB_O and CYC_O at the same time!
This means cycle and strobe are the same thing during "Classic standard SINGLE READ Cycle".

(MASTER_STATE_MACHINE_STATE: IDLE
master waits command to start a read or write cycle)

(MASTER_STATE_MACHINE_STATE: INIT_READ)
- The master asserts STB_O and CYC_O.
- The master deassert WE_O to denote a read operation.
- The master assert WE_O to denote a write operation.
- The master places an address onto ADR_O. 
(Master transitions to MASTER_STATE_MACHINE_STATE: WAIT_FOR_CYCLE_TERMINATING_SIGNALS)

Then the first positive clockedge happens (CLOCK EDGE 0).
(SLAVE is in IDLE state.)
The slave sees STB_O, CYC_O, ADR_O asserted and WE=0 at CLOCK EDGE 0. (slave transitions from IDLE to READ)
The slave starts to process data. It can immediately present data on [DAT_I()] or
it can insert wait states until it presents data on [DAT_I()].
By ACK_I the slave terminates the cycle. It could also return any one of the cycle terminating signals [ACK_I], [ERR_I] or [RTY_I].
This means, the slave can terminate the strobe and cycle with a success response (ACK_I) and error response (ERR_I) or
restart the cycle using RTY_I.

## CLOCK EDGE 1 (might be any cycle after edge 1 because wait states can be asserted).CLOCK EDGE 1 is a symbolic name.
When the slave has eventually processed the read request and has presented data on [DAT_I()], it will assert ACK_I.
(MASTER sees ACK_I and transitions to from WAIT_FOR_CYCLE_TERMINATING_SIGNALS to STOP. In STOP the master deasserts [STB_O] and [CYC_O])
The slave will keep ACK_I asserted until the master negates [STB_O] and [CYC_O] to indicate the end of the cycle.


## CLOCK EDGE 2
The master reads the slave's data on [DAT_I()]
The MASTER negates [STB_O] and [CYC_O] to indicate the end of the cycle.
(MASTER sees ACK_I and transitions to from WAIT_FOR_CYCLE_TERMINATING_SIGNALS to STOP. In STOP the master deasserts [STB_O] and [CYC_O])
SLAVE negates [ACK_I] in response to negated [STB_O].
(SLAVE transitions from READ to IDLE).

(When ACK_I goes low, the master transitions from STOP to IDLE)


What is a use case that contains more than one strobe/phase in a cycle?
This happens during 3.3 BLOCK READ / WRITE Cycles!







Simpler Version of the example:

Example UART RX using 3.2.1 Classic standard SINGLE READ Cycle (= one strobe/phase per cycle)

(first strobe/phase, first cycle)
- The master uses address 0x00 in order to read the "DATA_PRESENT" information.
- If "DATA_PRESENT" return false, the FPGA will blink all LEDS twice, then turn the LEDs off
completely (display a zero.)

(second strobe/phase, second cycle)
- If data is in fact present in the RX buffer, then the master uses the address 0x01 to read a single byte from the RX buffer!
- For each byte read, the slave will remove that byte from the buffer! and "DATA_PRESENT" will return false when asked.
- The FPGA will display a read byte using the 6 LEDs.

If the UART RX receives a character it overrides the last character (buffer has only a size of 1 byte)
Whenever a byte is received, "DATA_PRESENT" will return true when asked.

Steps for "Simpler Version of the example":
1. RX to 1-byte buffer, display the byte using the 6 LEDs

2. Write Wishbone Master and slave










Example UART RX using 3.2.1 Classic standard SINGLE READ Cycle (= one strobe/phase per cycle)

The user presses the user button (Debounced!)

(first strobe/phase, first cycle)
- The master uses address 0x00 in order to read the "DATA_PRESENT" information.

(second strobe/phase, second cycle)
- If data is in fact present in the RX buffer, then the master uses the address 0x01 to read a single byte from the RX buffer!
- For each byte read, the slave will remove that byte from the buffer!

The FPGA will display a read byte using the 6 LEDs.
If no byte is read from the RX slave because the input buffer is empty, The FPGA will blink all LEDS twice, then turn the LEDs off
completely (display a zero.)





Example:

User Button pressed - LEDs blink twice (because buffer is empty)

A byte 0x03 is sent to the FPGA
A byte 0x06 is sent to the FPGA

User Button pressed - 0x03 is displayed on the LEDs
User Button pressed - 0x06 is displayed on the LEDs

User Button pressed - LEDs blink twice, then are off (because buffer is empty)




Implementation:

State Machine for Wishbone Read Address 0x00 and then Address 0x01

Circular buffer for RX buffer.

UART RX to receive data

